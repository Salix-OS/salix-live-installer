#!/usr/bin/env python

#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
#                                                                             #
# Salix installer will install Salix on your computer from the comfort of     #
# SalixLive's graphic environment.                                            #
#                                                                             #
# Copyright Pierrick Le Brun <akuna~at~free~dot~fr>.                          #
#                                                                             #
# This program is free software; you can redistribute it and/or               #
# modify it under the terms of the GNU General Public License                 #
# as published by the Free Software Foundation; either version 2              #
# of the License, or (at your option) any later version.                      #
#                                                                             #
# This program is distributed in the hope that it will be useful,             #
# but WITHOUT ANY WARRANTY; without even the implied warranty of              #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               #
# GNU General Public License for more details.                                #
#                                                                             #
# You should have received a copy of the GNU General Public License           #
# along with this program; if not, write to the Free Software                 #
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. #
#                                                                             #
#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#

# Version='0.1'		- 20091027-build	First version

import commands
import os
import gtk
import sys
import pygtk
pygtk.require('2.0')

# To do => Internationalization

class SalixGuiInstaller:
			
    def __init__(self):

		builder = gtk.Builder()
		if os.path.exists("/share/salix-live-installer/salix-live-installer.glade") :
			builder.add_from_file("/share/salix-live-installer/salix-live-installer.glade")
		elif os.path.exists("../share/salix-live-installer/salix-live-installer.glade") :
			builder.add_from_file("../share/salix-live-installer/salix-live-installer.glade") 
		else :
			builder.add_from_file("salix-live-installer.glade")

		# Get a handle on the glade file widgets we want to interact with
		self.Window = builder.get_object("main_window")
		self.AboutDialog = builder.get_object("about_dialog")
		self.InfoDialog = builder.get_object("info_dialog")
		self.InfoLabel = builder.get_object("info_label")
		self.KeyboardCheck = builder.get_object("keyboard_check")
		self.LocaleCheck = builder.get_object("locale_check")
		self.PartitionCheck = builder.get_object("partition_check")
		self.UsersCheck = builder.get_object("users_check")
		self.PackagesCheck = builder.get_object("packages_check")
		self.KeyboardCheckMarker = builder.get_object("keyboard_check_marker")
		self.LocaleCheckMarker = builder.get_object("locale_check_marker")
		self.PartitionCheckMarker = builder.get_object("partition_check_marker")
		self.UsersCheckMarker = builder.get_object("users_check_marker")
		self.PackagesCheckMarker = builder.get_object("packages_check_marker")
		self.KeyboardBox = builder.get_object("keyboard_box")
		self.LocaleBox = builder.get_object("locale_box")
		self.MainPartitionBox = builder.get_object("main_partition_box")
		self.LinuxPartitionBox = builder.get_object("linux_partition_box")
		self.WindowsPartitionBox = builder.get_object("windows_partition_box")
		self.RecapPartitionBox = builder.get_object("recap_partition_box")		
		self.UsersBox = builder.get_object("users_box")
		self.PackagesBox = builder.get_object("packages_box")
		self.KeyboardList = builder.get_object("keyboard_list")
		self.KeyboardListStore = builder.get_object("keymap_list_store")
		self.KeyboardSelection = builder.get_object("keyboard_selection")
		self.LocaleList = builder.get_object("locale_list")
		self.LocaleListStore = builder.get_object("locale_list_store")
		self.LocaleSelection = builder.get_object("locale_selection")
		self.MainPartitionList = builder.get_object("main_partition_list")
		self.MainPartitionListStore = builder.get_object("main_partition_list_store")
		self.MainFormatCombobox = builder.get_object("main_format_combobox")		
		self.MainFormatListStore = builder.get_object("main_format_list_store")		
		self.LinuxPartitionList = builder.get_object("linux_partition_list")
		self.LinuxPartitionListStore = builder.get_object("linux_partition_list_store")
		self.WindowsPartitionList = builder.get_object("win_partition_list")
		self.WindowsPartitionListStore = builder.get_object("win_partition_list_store")
		self.RecapPartitionList = builder.get_object("recap_partition_list")
		self.RecapPartitionListStore = builder.get_object("recap_partition_list_store")		
		self.ConfirmPartitionDialog = builder.get_object("confirm_partition_dialog")
		self.ConfirmPartitionLabel = builder.get_object("confirm_partition_label")
		self.LinuxNewSysComboCell = builder.get_object("linux_newsys_renderer_combo")
		self.LinuxNewSysColumn = builder.get_object("linux_newsys_column")
		self.LinuxFormatListStore = builder.get_object("linux_format_list_store")
		self.LinuxNewMountComboCell = builder.get_object("linux_newmount_renderer_combo")
		self.LinuxNewMountColumn = builder.get_object("linux_newmount_column")	
		self.LinuxMountListStore = builder.get_object("linux_mountpoint_list_store")
		self.WinMountComboCell = builder.get_object("win_newmount_renderer_combo")
		self.WinMountColumn = builder.get_object("win_newmount_column")	
		self.WinMountListStore = builder.get_object("win_mountpoint_list_store")
		self.MainPartRecapLabel = builder.get_object("main_part_recap_label")
		self.LinPartRecapLabel = builder.get_object("lin_part_recap_label")				
		self.WinPartRecapLabel = builder.get_object("win_part_recap_label")
		self.LiveKernelRadioButton = builder.get_object("live_kernel_radiobutton")
		self.SalixKernelRadioButton = builder.get_object("salix_kernel_radiobutton")
		self.CoreRadioButton = builder.get_object("core_radiobutton")
		self.BasicRadioButton = builder.get_object("basic_radiobutton")
		self.FullRadioButton = builder.get_object("full_radiobutton")
		self.PackagesApplyButton = builder.get_object("packages_apply")
		self.KeyboardApplyButton = builder.get_object("keyboard_apply")
		self.LocaleApplyButton = builder.get_object("locale_apply")
		self.RootPass1Entry = builder.get_object("root_pass1_entry")	
		self.RootPass2Entry = builder.get_object("root_pass2_entry")
		self.UserPass1Entry = builder.get_object("user_pass1_entry")
		self.UserPass2Entry = builder.get_object("user_pass2_entry")			
		self.UserLoginEntry = builder.get_object("user_login_entry")
		self.UserVisibleCheckButton = builder.get_object("user_visible_checkbutton")
		self.RootVisibleCheckButton = builder.get_object("root_visible_checkbutton")
		self.ExternalDeviceCheckButton = builder.get_object("external_device_checkbutton")
		self.RootPassCreated = builder.get_object("root_pass_created")
		self.NewUserLogin = builder.get_object("new_user_login")
		self.UsersApplyButton = builder.get_object("users_apply")
		self.RootPassApplyButton = builder.get_object("rootpass_apply")
		self.InstallButton = builder.get_object("install_button")
		
		# Connect signals
		builder.connect_signals(self)
		
		
### INITIALIZATION ###

		# Shows the Intro widow while lists are initialized
		self.InfoDialog.show()
		
		### Initialise some global variables ###
		# Prevent switching to another tab until the current configuration is completed or cancelled
		global switch_tab_lock
		switch_tab_lock = ''
		# Control which partition box is shown depending if the configuration is set or not
		global partition_done_lock
		partition_done_lock = ''
		# The other partition lists needs to know what has been chosen as the main partition 
		global Selected_Main_Partition
		Selected_Main_Partition = ''
		# Initialize the lock system preventing the Install button to be activated prematurely
		global ConfigurationSet
		ConfigurationSet = ['no'] * 6
		# Initialise the external device checkbutton value
		global show_external_device
		show_external_device = 'no'
		
		
		# Initialize the passwords entry box to not display characters
		self.UserPass1Entry.set_visibility(False)
		self.UserPass2Entry.set_visibility(False)
		self.RootPass1Entry.set_visibility(False)
		self.RootPass2Entry.set_visibility(False)
					
		# Initialize the keymap list
		self.KeyboardListStore.clear()
		KeymapsFeedList = []
		global UsedKeyMap
		UsedKeyMap = 'None'
		# Open & parse SalixTools keymaps file
		SalixKeymapList = open('/usr/share/salixtools/keymaps', 'r')		
		for line in SalixKeymapList:
			# Nothing interesting in the commented lines
			if '#' not in line:
				# Only retrieve the available keymaps, the first 'argument' of each line
				AvailableKeymap = line.split('|')[0]
				# Put each available keymap in a list
				KeymapsFeedList.append(AvailableKeymap)
		# Prepare the available keymaps list along with their matching type
		global keyb_item
		for keyb_item in KeymapsFeedList:
			# Check if it is the one being used by the environment by parsing rc.keymap:
			UsedKeymapFile = open('/etc/rc.d/rc.keymap', 'r')
			for line in UsedKeymapFile:
				if keyb_item +'.map' in line:
					UsedKeyMap = keyb_item
			# Determine if azerty is the type of keyboard
			if os.path.exists('/usr/share/kbd/keymaps/i386/azerty/'+keyb_item+'.map.gz'):
				type = 'azerty'
				# If so, make a set of the keyboard & its corresponding type
				keyb_feedline = (keyb_item, type)
				# And populate the GUI keymap list view
				self.KeyboardListStore.append(keyb_feedline)
			# Determine if dvorak is the type of keyboard
			elif os.path.exists('/usr/share/kbd/keymaps/i386/dvorak/'+keyb_item+'.map.gz'):
				type = 'dvorak'
				# If so, make a set of the keyboard & its corresponding type
				keyb_feedline = (keyb_item, type)
				# And populate the GUI keymap list view
				self.KeyboardListStore.append(keyb_feedline)
			# Determine if qwerty is the type of keyboard	
			elif os.path.exists('/usr/share/kbd/keymaps/i386/qwerty/'+keyb_item+'.map.gz'):
				type = 'qwerty'
				# If so, make a set of the keyboard & its corresponding type
				keyb_feedline = (keyb_item, type)
				# And populate the GUI keymap list view
				self.KeyboardListStore.append(keyb_feedline)
			# Determine if qwertz is the type of keyboard
			elif os.path.exists('/usr/share/kbd/keymaps/i386/qwertz/'+keyb_item+'.map.gz'):
				type = 'qwertz'
				# If so, make a set of the keyboard & its corresponding type
				keyb_feedline = (keyb_item, type)
				# And populate the GUI keymap list view
				self.KeyboardListStore.append(keyb_feedline)

			# Close the opened files
			UsedKeymapFile.close()	  
		SalixKeymapList.close()
			
		# Initialize the locale list
		self.LocaleListStore.clear()	
		global UsedLocale
		UsedLocale = 'None'
		locale_list = []
		descript_list = []
		# Use non-localized environment to avoid problems
		os.environ['LANG'] = 'en_US'
		# Parse locale output with a basic stripping of relevant lines	
		locale_shell_output = "locale -cva | grep -A 2 utf8 | sed -e '/^-/d' -e 's/ *directory.*utf8//' -e 's/^ *title | //'"
		stripped_locale_output = commands.getoutput(locale_shell_output)
		# Break the lines into list items
		locale_output_list = stripped_locale_output.splitlines()
		# Further stripping & categorizing of relevant info
		for item in locale_output_list:
			if 'utf8' in item:
				locale_item = item.replace('locale: ', '')
				# Store the locale 
				locale_list.append(locale_item)
				# Check if it is the one being used by the environment:
				UsedLocaleFile = open('/etc/profile.d/lang.sh', 'r')
				for line in UsedLocaleFile:
					if locale_item in line:
						UsedLocale = locale_item
				UsedLocaleFile.close()	
			else:
				# Store the locale description
				descript_list.append(item)	
		# Make a set of the locale & its description 			
		LocaleFeedList = zip(locale_list,descript_list)
		# Populate the GUI locale list view		
		global locale_set
		for locale_set in LocaleFeedList:
			locale_set = list(locale_set)
			self.LocaleListStore.append(locale_set)

		# Initialize the main partitions list. 
		# This is a def since it may have to be done a few times depending on the user's choices.
		global partition_list_initialization
		def partition_list_initialization() :
			global part_feedline_list
			part_feedline_list = []
			self.MainPartitionListStore.clear()	
			# Use non-localized environment to avoid problems
			os.environ['LANG'] = 'en_US'
			# Detect all partitions except swap and extended		
			strip_swap_extended = 'parted -sl | grep -v swap | grep -v extended'
			global parted_output
			parted_output = commands.getoutput(strip_swap_extended).splitlines()	
			# Initialize the different variables	
			disk_name = ''
			disk_size = ''
			disk_device = ''
			part_name = ''
			part_size = ''
			part_system = ''
			part_feedline = ''
			# Parse each line of parted output
			for line in parted_output:
				# Get the name of each hard drive
				if 'Model:' in line:
					model_string = line
					# Some hard drives insert ATA before their name
					if 'ATA' in model_string:
						disk_name = model_string.split()[2]
					else:
						disk_name = model_string.split()[1]
				# Get the device reference & size of the disk
				elif 'Disk' in line:
					disk_device = line.split()[1]
					disk_size = line.split()[2]
				# Get the size & filesystem for each partition of the disk
				elif line.startswith(' '):
					part_name = disk_device.replace(':', '') + line.split() [0]
					part_size = line.split() [3]
					part_system = line.split() [5]				
					# Check if removable devices should be displayed.
					if show_external_device == 'yes' :
						# Put all needed variables in one set per line
						part_feedline = [disk_name +' (' + disk_size + ')', part_name, part_size, part_system] 
						# Put each set in a list
						part_feedline_list.append(part_feedline)							
					else :						
						usb_dev = ''
						dev_root = part_name[5:-1]
						check_if_usb = 'udevadm info -a -p /sys/block/' + dev_root + ' | grep -m1 /usb'
						usb_dev = commands.getoutput(check_if_usb)	
						if usb_dev != '' :
							pass
						else:
							# Put all needed variables in one set per line
							part_feedline = [disk_name +' (' + disk_size + ')', part_name, part_size, part_system] 
							# Put each set in a list
							part_feedline_list.append(part_feedline)
			# Sort the list for the partitions who do not follow the hard drive order
			part_feedline_list.sort()
			# Populate GUI partition list view rows
			for line in part_feedline_list:
				self.MainPartitionListStore.append(line)
			# Set the cursor on the first row
			self.MainPartitionList.set_cursor(0)
	
		partition_list_initialization()			

  
	### Callback signals waiting in a constant loop: ###	
	
### WINDOWS MAIN SIGNALS ###	
	
	# What to do when the exit X on the main window upper right is clicked
    def gtk_main_quit(self, widget, data=None):
        gtk.main_quit()

	# What to do when the Salix Installer quit button is clicked
    def on_button_quit_clicked(self, widget, data=None):
        gtk.main_quit()

    # What to do when Salix Installer logo is clicked
    def on_about_link_clicked(self, widget, data=None):
		self.AboutDialog.show()

    # What to do when the about dialog quit button is clicked
    def on_about_dialog_close(self, widget, data=None):
		self.AboutDialog.hide()

    # What to do when the Info dialog quit button is clicked
    def on_info_button_clicked(self, widget, data=None):
		self.InfoDialog.hide()

# LISTS ROWS ###

	# What to do when a keymap list row is added
    def on_keymap_list_store_row_inserted(self, widget, value, treeiter):
		# Check if it is the path of the used keymap to set the cursor on it 
		if keyb_item == UsedKeyMap:
			self.KeyboardList.set_cursor(value)

	# What to do when a locale list row is added			
    def on_locale_list_store_row_inserted(self, widget, value, treeiter):
		# Check if it is the path of the used locale to set the cursor on it 
		if UsedLocale in locale_set:
			global UsedLocaleRow
			UsedLocaleRow = value		
			
### COMBO LINES ###

	# What to do when a combo line is switched in the Linux New system column
    def on_linux_newsys_renderer_combo_changed(self, widget, row_number, combo_iter):
		# Retrieve the selected Linux partition combo row new text value
		new_text = self.LinuxFormatListStore.get_value(combo_iter, 0)
		linuxformatchoice = self.LinuxPartitionList.get_selection()
		self.LinuxPartitionListStore, iter = linuxformatchoice.get_selected()
		# Set the new partition row value on the fifth column (4)
		self.LinuxPartitionListStore.set_value(iter, 4, new_text)
		# It throws a gtk warning but still does the job & do not seem to be a problem (for the moment)
		
	# What to do when a combo line is edited in the Linux New system column
    def on_linux_newsys_renderer_combo_edited(self, widget, row_number, new_text):
		# Retrieve the selected Linux partition row iter
		linuxnewsyschoice = self.LinuxPartitionList.get_selection()
		self.LinuxPartitionListStore, iter = linuxnewsyschoice.get_selected()
		# Set the new partition row value on the fifth column (4)
		self.LinuxPartitionListStore.set_value(iter, 4, new_text)

	# What to do when a combo line is switched in the Linux mountpoint column
    def on_linux_newmount_renderer_combo_changed(self, widget, row_number, combo_iter):
		# Retrieve the selected Linux partition combo row new text value
		new_text = self.LinuxMountListStore.get_value(combo_iter, 0)
		linuxmountchoice = self.LinuxPartitionList.get_selection()
		self.LinuxPartitionListStore, iter = linuxmountchoice.get_selected()
		# Set the new partition row value on the fifth column (5)
		self.LinuxPartitionListStore.set_value(iter, 5, new_text)
		# Probably the same as above (but there is only one global warning)

	# What to do when a combo line is edited in the Linux mountpoint column
    def on_linux_newmount_renderer_combo_edited(self, widget, row_number, new_text):
		# Retrieve the selected Linux partition row iter
		linuxnewmountchoice = self.LinuxPartitionList.get_selection()
		self.LinuxPartitionListStore, iter = linuxnewmountchoice.get_selected()
		# Set the new partition row value on the sixth column (5)
		self.LinuxPartitionListStore.set_value(iter, 5, new_text)
		
	# What to do when a combo line is switched in the Windows mountpoint column		
    def on_win_newmount_renderer_combo_changed(self, widget, row_number, combo_iter):
		# Retrieve the selected Windows partition combo row new text value
		new_text = self.WinMountListStore.get_value(combo_iter, 0)
		# Retrieve the selected Windows partition row iter
		windowsnewmountchoice = self.WindowsPartitionList.get_selection()
		self.WindowsPartitionListStore, iter = windowsnewmountchoice.get_selected()
		# Set the new mountpoint row value on the fifth column (4)
		self.WindowsPartitionListStore.set_value(iter, 4, new_text)
		
	# What to do when a combo line is edited in the Windows mountpoint column		
    def on_win_newmount_renderer_combo_edited(self, widget, row_number, new_text,):
		# Retrieve the selected Windows partition row iter
		windowsnewmountchoice = self.WindowsPartitionList.get_selection()
		self.WindowsPartitionListStore, iter = windowsnewmountchoice.get_selected()
		# Set the new mountpoint row value on the fifth column (4)
		self.WindowsPartitionListStore.set_value(iter, 4, new_text)

# CONFIGURATION APPLY BUTTONS ###

	# What to do when the keyboard selection button is clicked
    def on_keyboard_apply_clicked(self, widget, data=None):		
		# Retrieve the selected keyboard map row iter
		keybselection = self.KeyboardList.get_selection()
		self.KeyboardListStore, iter = keybselection.get_selected()
		# Retrieve the selected keyboard map row value from the first column (0)
		global Selected_Keyboard
		Selected_Keyboard = self.KeyboardListStore.get_value(iter, 0)
		# Display the selected keyboard map
		self.KeyboardSelection.set_text(Selected_Keyboard)
		# Display the 'Done' check
		self.KeyboardCheck.show()
		self.KeyboardCheckMarker.hide()
		self.KeyboardList.set_sensitive(False)		
		self.KeyboardApplyButton.set_sensitive(False)
		global ConfigurationSet
		ConfigurationSet[0] = 'yes'
		if 'no' not in ConfigurationSet :
			self.InstallButton.set_sensitive(True)

	# What to do when the language selection button is clicked	
    def on_locale_apply_clicked(self, widget, data=None):
		# Retrieve the selected language row iter
		localeselection = self.LocaleList.get_selection()
		self.LocaleListStore, iter = localeselection.get_selected()
		# Retrieve the selected language row value from the first column (0)
		global Selected_Locale
		Selected_Locale = self.LocaleListStore.get_value(iter, 0)
		# Display the selected language map
		self.LocaleSelection.set_text(Selected_Locale)
		# Display the 'Done' check
		self.LocaleCheck.show()
		self.LocaleCheckMarker.hide()
		self.LocaleList.set_sensitive(False)	
		self.LocaleApplyButton.set_sensitive(False)
		global ConfigurationSet
		ConfigurationSet[1] = 'yes'
		if 'no' not in ConfigurationSet :
			self.InstallButton.set_sensitive(True)

	# What to do when the main partition selection button is clicked
    def on_main_partition_apply_clicked(self, widget, data=None):
		# Tell the confirmation dialog what it is dealing with
		global MainPartitionConfirmation
		MainPartitionConfirmation = True
		global LinuxPartitionConfirmation
		LinuxPartitionConfirmation = False
		global WindowsPartitionConfirmation
		WindowsPartitionConfirmation = False
		# Retrieve the selected main partition row iter
		mainpartitionselection = self.MainPartitionList.get_selection()
		self.MainPartitionListStore, iter = mainpartitionselection.get_selected()
		# Retrieve the selected main partition row value from the second column (1)
		global Selected_Main_Partition
		Selected_Main_Partition = self.MainPartitionListStore.get_value(iter, 1)
		# Retrieve the format selection
		Selected_Main_Format = self.MainFormatCombobox.get_active_text()
		# Ask the user to confirm or undo his choice
		global MainPartConfirmLabel
		MainPartConfirmLabel = Selected_Main_Partition + " will be formatted with " + Selected_Main_Format + " and will be mounted as /. \n"
		self.ConfirmPartitionLabel.set_text(MainPartConfirmLabel)
		self.ConfirmPartitionDialog.show()
					
	# What to do when the Linux partition Apply settings button is clicked
    def on_linux_partition_apply_clicked(self, widget, data=None):
		# Tell the confirmation dialog what it is dealing with
		global MainPartitionConfirmation
		MainPartitionConfirmation = False
		global WindowsPartitionConfirmation
		WindowsPartitionConfirmation = False
		global LinuxPartitionConfirmation
		LinuxPartitionConfirmation = True
		# Retrieve all the Linux partition rows data
		NewLinValues = []
		x = 0
		while x <= 20 :
			try :
				treeiter = self.LinuxPartitionListStore.get_iter(x)
				x += 1
				NewLinValues.append(self.LinuxPartitionListStore.get(treeiter, 1, 4, 5))
			except (ValueError) :
				break
		LinPartitionLabel = []
		UnsetValues = ('Select...', 'Do not format!', 'Do not mount!')
		for set in NewLinValues :
			if set[1] not in UnsetValues :
				if set[2] not in UnsetValues :
					LinPartitionLabel.append(set[0] + " will be formatted with " + set[1] + " and will be mounted as " + set[2] + ". \n")
				else :
					LinPartitionLabel.append(set[0] + " will be formatted with " + set[1] + " and will not be mounted. \n")
			else :
				if set[2] not in UnsetValues :
					LinPartitionLabel.append(set[0] + " will not be formatted and will be mounted as " + set[2] + ". \n")
				else :
					LinPartitionLabel.append(set[0] + " will not be formatted and will not be mounted. \n")
		FullConfirmationText = ''
		for i in LinPartitionLabel:
			FullConfirmationText += i
		global LinPartConfirmLabel
		LinPartConfirmLabel = FullConfirmationText 
		self.ConfirmPartitionLabel.set_text(FullConfirmationText)
		self.ConfirmPartitionDialog.show()
		
	# What to do when the Windows partition Apply settings button is clicked
    def on_windows_partition_apply_clicked(self, widget, data=None):
		# Tell the confirmation dialog what it is dealing with
		global MainPartitionConfirmation
		MainPartitionConfirmation = False
		global LinuxPartitionConfirmation
		LinuxPartitionConfirmation = False
		global WindowsPartitionConfirmation
		WindowsPartitionConfirmation = True		
		# Retrieve all the Windows partition rows data
		NewWinValues = []		
		x = 0
		while x <= 20 :
			try :
				treeiter = self.WindowsPartitionListStore.get_iter(x)
				x += 1
				NewWinValues.append(self.WindowsPartitionListStore.get(treeiter, 1, 4))
			except (ValueError) :
				break
		WinPartitionLabel = []
		UnsetValues = ('Select...', 'Do not mount!')
		for set in NewWinValues :
			if set[1] in UnsetValues :
				WinPartitionLabel.append(set[0] + " will not be formatted and will not be mounted. \n")
			else :
				WinPartitionLabel.append(set[0] + " will not be formatted and will be mounted as " + set[1] + ". \n")
		FullConfirmationText = ''
		for i in WinPartitionLabel:
			FullConfirmationText += i
		global WinPartConfirmLabel
		WinPartConfirmLabel = FullConfirmationText 
		self.ConfirmPartitionLabel.set_text(FullConfirmationText)
		self.ConfirmPartitionDialog.show()
		
	# What to do when the user's settings apply button is clicked
    def on_users_apply_clicked(self, widget, data=None):
		# Pass some basic sanity checks
		if self.UserLoginEntry.get_text() == '' :
			error_dialog("\nYour login entry is empty. Please verify and correct! \n")	
		elif self.UserPass1Entry.get_text() == '' :
			error_dialog("\nYour password entry is empty. Please verify and correct! \n")
		elif self.UserPass1Entry.get_text().replace(' ', '').isalnum() == False :
			error_dialog("\nYour password should only contain alphanumeric characters. Please verify and correct! \n")				
		elif len(self.UserPass1Entry.get_text()) < 5 :
			error_dialog("\nYour password is too short. It should have at least 5 characters. Please verify and correct! \n")			
		elif self.UserPass1Entry.get_text() != self.UserPass2Entry.get_text() :
			error_dialog("\nYour 2 password entries do not match. Please verify and correct! \n") 
		else :
			self.NewUserLogin.set_text(self.UserLoginEntry.get_text())
			if self.RootPassCreated.get_text() != "None" :
				self.UsersCheck.show()
				self.UsersCheckMarker.hide()
			global ConfigurationSet
			ConfigurationSet[3] = 'yes'
			if 'no' not in ConfigurationSet :
				self.InstallButton.set_sensitive(True)
			self.UserLoginEntry.set_sensitive(False)
			self.UserPass1Entry.set_sensitive(False)
			self.UserPass2Entry.set_sensitive(False)
			self.UserVisibleCheckButton.set_active(False)
			self.UserVisibleCheckButton.set_sensitive(False)
			self.UserPass1Entry.set_visibility(False)
			self.UserPass2Entry.set_visibility(False)
			self.UsersApplyButton.set_sensitive(False)
				
	# What to do when the root password settings apply button is clicked
    def on_rootpass_apply_clicked(self, widget, data=None):
		# Pass some basic sanity checks
		if self.RootPass1Entry.get_text() == '' :
			error_dialog("\nYour password entry is empty. Please verify and correct! \n")				
		elif self.RootPass1Entry.get_text().replace(' ', '').isalnum() == False :
			error_dialog("\nYour password should only contain alphanumeric characters. Please verify and correct! \n")	
		elif len(self.RootPass1Entry.get_text()) < 5 :
			error_dialog("\nYour password is too short. It should have at least 5 characters. Please verify and correct! \n")			
		elif self.RootPass1Entry.get_text() != self.RootPass2Entry.get_text() :
			error_dialog("\nYour 2 password entries do not match. Please verify and correct! \n") 
		else:
			self.RootPassCreated.set_text('Yes')
			if self.NewUserLogin.get_text() != "None" :
				self.UsersCheck.show()
				self.UsersCheckMarker.hide()
			global ConfigurationSet
			ConfigurationSet[4] = 'yes'
			if 'no' not in ConfigurationSet :
				self.InstallButton.set_sensitive(True)
			self.RootPass1Entry.set_sensitive(False)
			self.RootPass2Entry.set_sensitive(False)
			self.RootVisibleCheckButton.set_active(False)
			self.RootVisibleCheckButton.set_sensitive(False)
			self.RootPass1Entry.set_visibility(False)
			self.RootPass2Entry.set_visibility(False)
			self.RootPassApplyButton.set_sensitive(False)			

	# What to do when the package selection apply button is clicked
    def on_packages_apply_clicked(self, widget, data=None):
		self.CoreRadioButton.set_sensitive(False)
		self.BasicRadioButton.set_sensitive(False)
		self.FullRadioButton.set_sensitive(False)
		self.SalixKernelRadioButton.set_sensitive(False)
		self.LiveKernelRadioButton.set_sensitive(False)
		self.PackagesCheck.show()
		self.PackagesCheckMarker.hide()
		self.PackagesApplyButton.set_sensitive(False)
		global ConfigurationSet
		ConfigurationSet[5] = 'yes'
		if 'no' not in ConfigurationSet :
			self.InstallButton.set_sensitive(True)
			
### CONFIGURATION UNDO BUTTONS ###

	# What to do when the keyboard undo button is clicked
    def on_keyboard_undo_clicked(self, widget, data=None):
		# Remove the 'Done' check
		self.KeyboardCheck.hide()
		self.KeyboardCheckMarker.show()
		# Reset the selection to none
		self.KeyboardSelection.set_text('None')
		self.KeyboardList.set_sensitive(True)	
		self.KeyboardApplyButton.set_sensitive(True)
		global ConfigurationSet
		ConfigurationSet[0] = 'no'
		self.InstallButton.set_sensitive(False)
		
	# What to do when the language undo button is clicked
    def on_locale_undo_clicked(self, widget, data=None):
		# Remove the 'Done' check
		self.LocaleCheck.hide()
		self.LocaleCheckMarker.show()
		# Reset the selection to none
		self.LocaleSelection.set_text('None')
		self.LocaleList.set_sensitive(True)	
		self.LocaleApplyButton.set_sensitive(True)
		global ConfigurationSet
		ConfigurationSet[1] = 'no'
		self.InstallButton.set_sensitive(False)
				
	# What to do when the partition recap undo button is clicked
    def on_partition_recap_undo_clicked(self, widget, data=None):
		# Blank Recap box + 'Done' Check & displays the main partition configuration box
		global partition_done_lock
		partition_done_lock = ''
		partition_list_initialization()
		self.PartitionCheck.hide()
		self.PartitionCheckMarker.show()
		self.MainPartitionBox.show()
		self.RecapPartitionBox.hide()
		global ConfigurationSet
		ConfigurationSet[2] = 'no'
		self.InstallButton.set_sensitive(False)
				
	# What to do when the user's settings undo button is clicked
    def on_users_undo_clicked(self, widget, data=None):
		self.UsersCheck.hide()
		self.UsersCheckMarker.show()
		self.UserLoginEntry.set_sensitive(True)
		self.UserLoginEntry.set_text('')
		self.UserPass1Entry.set_sensitive(True)
		self.UserPass1Entry.set_text('')
		self.UserPass2Entry.set_sensitive(True)
		self.UserPass2Entry.set_text('')
		self.UsersApplyButton.set_sensitive(True)
		self.UserVisibleCheckButton.set_sensitive(True)
		self.NewUserLogin.set_text('None')
		global ConfigurationSet
		ConfigurationSet[3] = 'no'
		self.InstallButton.set_sensitive(False)
						
	# What to do when the root password settings undo button is clicked
    def on_rootpass_undo_clicked(self, widget, data=None):
		self.UsersCheck.hide()
		self.UsersCheckMarker.show()		
		self.RootPass1Entry.set_sensitive(True)
		self.RootPass1Entry.set_text('')
		self.RootPass2Entry.set_sensitive(True)
		self.RootPass2Entry.set_text('')
		self.RootVisibleCheckButton.set_sensitive(True)
		self.RootPassApplyButton.set_sensitive(True)	
		self.RootPassCreated.set_text('None')
		global ConfigurationSet
		ConfigurationSet[4] = 'no'
		self.InstallButton.set_sensitive(False)
		
	# What to do when the package selection undo button is clicked
    def on_packages_undo_clicked(self, widget, data=None):
		self.CoreRadioButton.set_sensitive(True)
		self.BasicRadioButton.set_sensitive(True)
		self.FullRadioButton.set_sensitive(True)
		self.SalixKernelRadioButton.set_sensitive(True)
		self.LiveKernelRadioButton.set_sensitive(True)
		self.PackagesCheck.hide()
		self.PackagesCheckMarker.show()
		self.PackagesApplyButton.set_sensitive(True)
		global ConfigurationSet
		ConfigurationSet[5] = 'no'
		self.InstallButton.set_sensitive(False)

### PARTITION CONFIRMATION WINDOW ###
						
	# What to do when the yes button of the partition confirmation dialog is clicked
    def on_confirm_button_clicked(self, widget, data=None):
		global partition_done_lock
		partition_done_lock = ''
		# Check what is being confirmed & act accordingly
		if MainPartitionConfirmation == True :
			# Prevent tab switching until all partitions settings are complete
			global switch_tab_lock
			switch_tab_lock = 'on' 
			# Tell the installer if there are extra partitions to set:
			global extra_part_toset
			extra_part_toset = []
			# Initialize the Linux partitions list
			self.LinuxPartitionListStore.clear()
			for set in part_feedline_list :
				if Selected_Main_Partition not in set :
					# Use non-localized environment to avoid problems
					os.environ['LANG'] = 'en_US'
					# Parse fdisk -l output (This will not work with raid disks)
					fdisk_shell_output = "fdisk -l | grep " + set[1]
					stripped_fdisk_output = commands.getoutput(fdisk_shell_output)
					if "Linux" in stripped_fdisk_output :
						# Let the installer know about it:
						extra_part_toset.append('linux')
						# Insert editable combobox in appropriate list cells for new formatting configuration 	
						self.LinuxNewSysComboCell.set_property("model", self.LinuxFormatListStore)
						self.LinuxNewSysComboCell.set_property('text-column', 0)
						self.LinuxNewSysComboCell.set_property('editable', True)
						self.LinuxNewSysColumn.set_attributes(self.LinuxNewSysComboCell, text = 4)
						set.append("Select...")
						# Insert editable combobox in appropriate list cells for new mounting configuration 	
						self.LinuxNewMountComboCell.set_property("model", self.LinuxMountListStore)
						self.LinuxNewMountComboCell.set_property('text-column', 0)
						self.LinuxNewMountComboCell.set_property('editable', True)
						self.LinuxNewMountColumn.set_attributes(self.LinuxNewMountComboCell, text = 5)
						set.append("Select...")
						# Add the partition's data row to the list view
						self.LinuxPartitionListStore.append(set)
						# Set the cursor on the first row
						self.LinuxPartitionList.set_cursor(0)	

			# Initialize the Windows partitions list
			self.WindowsPartitionListStore.clear()	
			for set in part_feedline_list :
				if Selected_Main_Partition not in set :
					# Use non-localized environment to avoid problems
					os.environ['LANG'] = 'en_US'
					# Parse fdisk -l output (This will not work for raid disks)
					fdisk_shell_output = "fdisk -l | grep " + set[1]
					stripped_fdisk_output = commands.getoutput(fdisk_shell_output)
					winsys = ('NTFS', 'FAT32')
					for i in winsys :
						if i in stripped_fdisk_output :
							# Let the installer know about it:
							extra_part_toset.append('windows')
							# Insert editable combobox in appropriate list cells for new mounting configuration 	
							self.WinMountComboCell.set_property("model", self.WinMountListStore)
							self.WinMountComboCell.set_property('text-column', 0)
							self.WinMountComboCell.set_property('editable', True)
							self.WinMountColumn.set_attributes(self.WinMountComboCell, text = 4)
							set.append("Select...")
							# Add the partition's data row to the list view
							self.WindowsPartitionListStore.append(set)
							# Set the cursor on the first row
							self.WindowsPartitionList.set_cursor(0)	
						
			# Display the extra Linux partitions configuration if appropriate
			if 'linux' in extra_part_toset :
				self.ConfirmPartitionDialog.hide()
				self.MainPartitionBox.hide()
				self.LinuxPartitionBox.show()
			# Else display the Windows partitions configuration if appropriate
			elif 'windows' in extra_part_toset :
				self.ConfirmPartitionDialog.hide()
				self.MainPartitionBox.hide()
				self.WindowsPartitionBox.show() 
			else :
				# Set all infos on the recap box, display it, unlock tabs & display partition check 
				partition_done_lock = 'on'
				switch_tab_lock = ''
				self.MainPartRecapLabel.set_text(MainPartConfirmLabel)
				self.LinPartRecapLabel.set_text('None \n') 
				self.WinPartRecapLabel.set_text('None \n')
				self.ConfirmPartitionDialog.hide()
				self.MainPartitionBox.hide()
				self.RecapPartitionBox.show()
				self.PartitionCheck.show()
				self.PartitionCheckMarker.hide()
				global ConfigurationSet
				ConfigurationSet[2] = 'yes'
				if 'no' not in ConfigurationSet :
					self.InstallButton.set_sensitive(True)
				 
		if LinuxPartitionConfirmation == True :
			# Display Windows partitions configuration if appropriate
			if 'windows' in extra_part_toset :
				self.ConfirmPartitionDialog.hide() 
				self.LinuxPartitionBox.hide() 
				self.WindowsPartitionBox.show() 
			else :
				# Set all infos on the recap box, display it, unlock tabs & display partition check 
				partition_done_lock = 'on'
				switch_tab_lock = ''
				self.MainPartRecapLabel.set_text(MainPartConfirmLabel)
				self.LinPartRecapLabel.set_text(LinPartConfirmLabel) 
				self.WinPartRecapLabel.set_text('None \n')
				self.ConfirmPartitionDialog.hide()
				self.LinuxPartitionBox.hide()
				self.RecapPartitionBox.show()
				self.PartitionCheck.show()
				self.PartitionCheckMarker.hide()
				ConfigurationSet[2] = 'yes'
				if 'no' not in ConfigurationSet :
					self.InstallButton.set_sensitive(True)
				
		if WindowsPartitionConfirmation == True :
			# Set all infos on the recap box, display it, unlock tabs & display partition check 
			partition_done_lock = 'on'
			switch_tab_lock = ''
			self.MainPartRecapLabel.set_text(MainPartConfirmLabel)
			self.LinPartRecapLabel.set_text(LinPartConfirmLabel) 
			self.WinPartRecapLabel.set_text(WinPartConfirmLabel)			
			self.ConfirmPartitionDialog.hide()
			self.WindowsPartitionBox.hide()
			self.RecapPartitionBox.show() 
			self.PartitionCheck.show()
			self.PartitionCheckMarker.hide()
			ConfigurationSet[2] = 'yes'
			if 'no' not in ConfigurationSet :
				self.InstallButton.set_sensitive(True)

	# What to do when the no button of the partition confirmation dialog is clicked	
    def on_do_not_confirm_button_clicked(self, widget, data=None):
		# Check what is being cancelled & act accordingly
		if MainPartitionConfirmation == True :
			global Selected_Main_Partition
			Selected_Main_Partition = ''
		if LinuxPartitionConfirmation == True :
			pass	
		if WindowsPartitionConfirmation == True :
			pass	
		self.ConfirmPartitionDialog.hide()
		
### CHECKBUTTONS ###
						
	# What to do when the user's password visible checkbutton is toggled		
    def on_user_visible_checkbutton_toggled(self, widget, data=None):		
		if self.UserVisibleCheckButton.get_active() == True :
			self.UserPass1Entry.set_visibility(True)
			self.UserPass2Entry.set_visibility(True)
		if self.UserVisibleCheckButton.get_active() == False :
			self.UserPass1Entry.set_visibility(False)
			self.UserPass2Entry.set_visibility(False)
		
	# What to do when the root's password visible checkbutton is toggled		
    def on_root_visible_checkbutton_toggled(self, widget, data=None):
		if self.RootVisibleCheckButton.get_active() == True :
			self.RootPass1Entry.set_visibility(True)
			self.RootPass2Entry.set_visibility(True)
		if self.RootVisibleCheckButton.get_active() == False :	
			self.RootPass1Entry.set_visibility(False)
			self.RootPass2Entry.set_visibility(False)
			
	# What to do when the external device checkbutton is toggled		
    def	on_external_device_checkbutton_toggled (self, widget, data=None):
		global show_external_device
		if self.ExternalDeviceCheckButton.get_active() == True :			
			show_external_device = 'yes'
		else :
			show_external_device = 'no'
		partition_list_initialization ()
			
		
### CONFIGURATION TABS ###
				
	# What to do when the keyboard tab is clicked
    def on_keyboard_tab_clicked(self, widget, data=None):
		if switch_tab_lock == 'on' :
			pass
		else :		
			# Show the keyboard setting area & hide all the others
			self.KeyboardBox.show()
			self.LocaleBox.hide()
			self.MainPartitionBox.hide()
			self.RecapPartitionBox.hide()
			self.UsersBox.hide()
			self.PackagesBox.hide()
		
	# What to do when the language tab is clicked
    def on_locale_tab_clicked(self, widget, data=None):
		if switch_tab_lock == 'on' :
			pass
		else :		
			self.KeyboardBox.hide()
			self.LocaleBox.show()
			self.LocaleList.set_cursor(UsedLocaleRow)
			self.MainPartitionBox.hide()
			self.RecapPartitionBox.hide()
			self.UsersBox.hide()
			self.PackagesBox.hide()
			
	# What to do when the partitions tab is clicked
    def on_partition_tab_clicked(self, widget, data=None):
		if switch_tab_lock == 'on' :
			pass
		else :		
			self.KeyboardBox.hide()
			self.LocaleBox.hide()
			self.UsersBox.hide()
			self.PackagesBox.hide()
			if partition_done_lock == 'on' :
				self.RecapPartitionBox.show()
				self.MainPartitionBox.hide()
			else :
				self.RecapPartitionBox.hide()
				self.MainPartitionBox.show()				

	# What to do when the users tab is clicked
    def on_users_tab_clicked(self, widget, data=None):
		if switch_tab_lock == 'on' :
			pass
		else :		
			self.KeyboardBox.hide()
			self.LocaleBox.hide()
			self.MainPartitionBox.hide()
			self.RecapPartitionBox.hide()
			self.UsersBox.show()
			self.PackagesBox.hide()

	# What to do when the packages tab is clicked
    def on_packages_tab_clicked(self, widget, data=None):
		if switch_tab_lock == 'on' :
			pass
		else :		
			self.KeyboardBox.hide()
			self.LocaleBox.hide()
			self.MainPartitionBox.hide()
			self.RecapPartitionBox.hide()
			self.UsersBox.hide()
			self.PackagesBox.show()

# Error window skeleton:
def error_dialog(message, parent = None):
	"""
	Displays an error message.
	
	"""
	dialog = gtk.MessageDialog(parent = parent, type = gtk.MESSAGE_ERROR, buttons = gtk.BUTTONS_CLOSE, flags = gtk.DIALOG_MODAL)
	dialog.set_markup(message)
	dialog.set_icon_from_file("/usr/share/icons/gnome-colors-common/scalable/actions/gtk-stop.svg")
	global result_error
	result_error = dialog.run()
	dialog.destroy()					

# Launch the application
if __name__ == '__main__':	
	# If no root privilege, displays error message & exit
    if os.getuid() != 0:
		error_dialog("<b>Sorry!</b> \n\nRoot privileges are required to run Salix Installer. ")
		sys.exit(1)
	# If root privilege, show the gui & wait for signals
    SalixGuiInstaller()
    gtk.main()

